1.并发：同一时间段内可以交替处理多个操作
![image](https://images2015.cnblogs.com/blog/610439/201602/610439-20160211001313120-360873824.png)
并行：同一时刻内同时处理多个操作
![image](https://images2015.cnblogs.com/blog/610439/201602/610439-20160211001344995-885099542.png)

# 并发的基本方式
1. 多进程并发
    多个进程独立的运行，他们之间通过进程间的通信渠道传递信息，这种进程间通信不是设置复杂就是速度慢，这是因为为了避免一个进程去修改另一个进程，操作系统在进程间提供了一定的保护措施，当然也使得安全的并发代码更加安全，容易。
运行多个进程需要固定的开销：进程的启动时间，进程的资源消耗
2. 多线程并发
在当个进程中运行多个线程也可以并发。线程就像轻量级的进程，每个线程相互独立运行，但它们共享地址空间，所有线程访问到的大部分数据如指针、对象引用或其他数据可以在线程之间进行传递，它们都可以访问全局变量。进程之间通常共享内存，但这种共享通常难以建立且难以管理，缺少线程间数据的保护。因此，在多线程编程中，我们必须确保每个线程锁访问到的数据是一致的。
# C++中的并发与多线程
C++11 标准提供了一个新的线程库，内容包括了管理线成，保护共享数据，线程间的同步操作，低级原子操作的各种类，标准极大的提高了程序的可移植性

C++11 新标准中引入了几个头文件来支持多线程编程：

- < thread > :包含std::thread类以及std::this_thread命名空间。管理线程的函数和类在 中声明.
- < atomic > :包含std::atomic和std::atomic_flag类，以及一套C风格的原子类型和与C兼容的原子操作的函数。
- < mutex > :包含了与互斥量相关的类以及其他类型和函数
- < future > :包含两个Provider类（std::promise和std::package_task）和两个Future类（std::future和std::shared_future）以及相关的类型和函数。
- < condition_variable > :包含与条件变量相关的类，包括std::condition_variable和std::condition_variable_any。
- 

---

```
#include<iostream>
#include<thread>

void fun(int a){
    a++;
}

int main(){

    int a=0;

    std::thread t(fun,a);  //创建一个线程t,t调用函数fun,a作为fun的参数，也要写到thread的构造函数当中；
    t.join();              //启动线程t,并且阻塞主线程，等到线程t运行结束后，再继续运行主线程；

    std::cout<<a<<std::endl;

}
```
在这里要说一下，thread类当中的两个成员函数，join()和detach()。这两个成员的作用就像上面代码的注释那样，启动新生成的线程的，但是区别在于join()函数是启动子线程而阻塞主线程，当子线程运行结束后，才会继续运行主线程。相比之下，detach()函数的作用是启动子线程，并且让子线程和主线程分离，子线程和主线程各运行各的，虽然两个线程会因为共享内存池的原因在操作系统的层面发生发生阻塞等关系，但是在代码层次上，两个线程并不存在谁阻塞谁，很可能主线程已经运行结束了，子线程还在运行。

其次，我们要说一下加锁和解锁的问题。
因为我们创造的每一个线程只要在一个进程内，都是共享内存池的，这样在读写数据可能会发生混乱。
C++11提供了mutex类进行加锁和解锁。


```
#include<iostream>
#include<thread>
#include<mutex>

std::mutex mut;

class A{

public:

    volatile int temp;

    A(){
        temp=0;
    }

    void fun(int num){

        int count=10;
        while(count>0){

            mut.lock();
            temp++;
            std::cout<<"thread_"<<num<<"...temp="<<temp<<std::endl;
            mut.unlock();

            count--;
        }
    }

    void thread_run(){
            std::thread t1(&A::fun,this,1);   

            std::thread t2(&A::fun,this,2);

            t1.join();
            t2.join();
    }
};

int main(){

    A a;

    a.thread_run();
}
```

然后，我们说一下volatile关键字。

volatile和const关键很相似，都是修饰变量的，只是二者功能不一样。
volatile在多线程当中经常使用，因为在某一线程多次调用某一个变量，编译器会进行优化，将该变量存放在在寄存器当中，不会每次都从内存当中读入。果然该变量同时在其他线程当中被修改，这样就会发生脏读取错误。

而加上volatile修饰，则会提醒编译器，这个变量可能会被改变，不能存放到寄存器当中，需要每次都从内存当中读取。

# 资源竞争

```
#include <iostream>
#include <thread>

using namespace std;

void output(int i)
{
    cout << i << endl;
}

int main()
{
    
    for (uint8_t i = 0; i < 4; i++)
    {
        thread t(output, i);
        t.detach(); 
    }
        
    getchar();
    return 0;
}
```
在一个for循环内，创建4个线程分别输出数字0、1、2、3，并且在每个数字的末尾输出换行符。语句thread t(output, i)创建一个线程t，该线程运行output，第二个参数i是传递给output的参数。t在创建完成后自动启动，t.detach表示该线程在后台允许，无需等待该线程完成，继续执行后面的语句。这段代码的功能是很简单的，如果是顺序执行的话，其结果很容易预测得到
但是在并行多线程下，其执行的结果就多种多样了，下图是代码一次运行的结果：

![image](https://images2015.cnblogs.com/blog/439761/201612/439761-20161205170856101-1150588218.png)
可以看出，首先输出了01，并没有输出换行符；紧接着却连续输出了2个换行符。不是说好的并行么，同时执行，怎么还有先后的顺序？这就涉及到多线程编程最核心的问题了资源竞争。CPU有4核，可以同时执行4个线程这是没有问题了，但是控制台却只有一个，同时只能有一个线程拥有这个唯一的控制台，将数字输出。将上面代码创建的四个线程进行编号：t0,t1,t2,t3，分别输出的数字：0,1,2,3。参照上图的执行结果，控制台的拥有权的转移如下：

t0拥有控制台，输出了数字0，但是其没有来的及输出换行符，控制的拥有权却转移到了t1；（0）
t1完成自己的输出，t1线程完成 （1\n）
控制台拥有权转移给t0，输出换行符 （\n）
t2拥有控制台，完成输出 （2\n）
t3拥有控制台，完成输出 （3\n)
由于控制台是系统资源，这里控制台拥有权的管理是操作系统完成的。但是，假如是多个线程共享进程空间的数据，这就需要自己写代码控制，每个线程何时能够拥有共享数据进行操作。共享数据的管理以及线程间的通信，是多线程编程的两大核心。

当线程启动后，一定要在和线程相关联的thread销毁前，确定以何种方式等待线程执行结束。C++11有两种方式来等待线程结束

- detach方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。前面代码所使用的就是这种方式。
- join方式，等待启动的线程完成，才会继续往下执行。假如前面的代码使用这种方式，其输出就会0,1,2,3，因为每次都是前一个线程输出完成了才会进行下一个循环，启动下一个新线程。