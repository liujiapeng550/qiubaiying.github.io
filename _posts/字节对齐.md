## 1.什么是内存对齐 

假设我们同时声明两个变量： 


```
char a; 

short b;
```


用&（取地址符号）观察变量a，b的地址的话，我们会发现（以16位CPU为例）： 

如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。 

那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？ 答案就是它确实没被使用。 因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。 

  

但是如果b的地址为0x0002， 

那么CPU只需一次读操作就可以获得b的值了。所以编译器为了优化代码，往往会根据变量的大小，将其指定到合适的位置，即称为内存对齐（对变量b做内存对齐，a、b之间的内存被浪费，a并未多占内存）。 

## 2.结构体内存对齐规则（请记住三条内存规则(在没有#pragam pack宏的情况下） 

结构体所占用的内存与其成员在结构体中的声明顺序有关，其成员的内存对齐规则如下： 

（1）每个成员分别按自己的对齐字节数和PPB（指定的对齐字节数，32位机默认为4）两个字节数最小的那个对齐，这样可以最小化长度。如在32bit的机器上，int的大小为4，因此int存储的位置都是4的整数倍的位置开始存储。 

（2）复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，结构体数组的时候，可以最小化长度。 

（3）结构体对齐后的长度必须是成员中最大的对齐参数（PPB）的整数倍，这样在处理数组时可以保证每一项都边界对齐。 

 （4）结构体作为数据成员的对齐规则：在一个struct中包含另一个struct，内部struct应该以它的最大数据成员大小的整数倍开始存储。如 struct A 中包含 struct B, struct B 中包含数据成员 char, int, double，则 struct B 应该以sizeof(double)=8的整数倍为起始地址。 


3.实例演示： 


```
struct A 

{ 

char a;　　　//内存位置:  [0] 

double b;　  // 内存位置: [8]...[15] 

int c;　　　　// 内存位置: [16]...[19]　　----　　规则1 

};　　　　　　　 // 内存大小：sizeof(A) = (1+7) + 8 + (4+4) = 24,
```
 补齐[20]...[23]　　----　　规则3 

  


```
struct B 

{ 

int a,　　　　// 内存位置: [0]...[3] 

A b,　    　　// 内存位置: [8]...[31]　　----　　规则2 

char c,　　　// 内存位置: [32] 

};　　　　　　　  // 内存大小：sizeof(B) = (4+4) + 24 + (1+7) = 40,
```
 补齐[33]...[39] 

*注释：(1+7)表示该数据成员大小为1，补齐7位；(4+4)同理。 




预备知识：基本类型占用字节 

在32位操作系统和64位操作系统上，基本数据类型分别占多少字节呢？ 


32位操作系统数据类型 | 字节长度
---|---
char | 1
int | 4
short|2
unsigned int |4
long | 4
unsigned long| 4
long long | 8
float | 4
double |8
指针|4



64位操作系统数据类型 | 字节长度
---|---
char | 1    
int |4 
short | 2
unsigned int | 4
long | 8
unsigned long | 8
long long | 8
float | 4
double | 8  
指针 | 8 


内存对齐： 

成员对齐有一个重要的条件，即每个成员按自己的方式对齐。其对齐的规则是：每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数(这里默认是8字节)中较小的一个对齐。并且结构的长度必须为所用过的所有对齐参数的整数倍。不够就补空字节。 


举例： 

```
struct t{ 

    long a; 

    short b; 

    int c; 

    int *d;  

    char e; 

}
```


在64位操作系统中的大小。 


分析： 


按照声明的顺序一个一个分配内存空间。 


首先 long 型变量a，在64位地址空间中，long型占8个字节，所以按照上面的对齐条件，这个成员应该按照对其参数 min(sizeof(long), 8) = 8字节来对齐，所以把这个成员存放在 0~7 内存单元中。 


然后 short型变量b，在64位地址空间中，short型占2个字节，所以按照上面的对齐条件，这个成员应该按照对其参数 min(sizeof(short), 8) = 2字节来对齐，所以把这个成员存放在 8~9 内存单元中。 


然后 int型变量c，在64位地址空间中，int型占4个字节，所以按照上面的对齐条件，这个成员应该按照对其参数 min(sizeof(int), 8) = 4字节来对齐，所以把这个成员存放在 12~15 内存单元中（10，11单元都不能被4整除）。 


然后 int*型变量d，在64位地址空间中，指针型占8个字节，所以按照上面的对齐条件，这个成员应该按照对其参数 min(sizeof(int*), 8) = 8字节来对齐，所以把这个成员存放在 16~23 内存单元中。 


然后 char型变量e，在64位地址空间中，char型占1个字节，所以按照上面的对齐条件，这个成员应该按照对其参数 min(sizeof(char), 8) = 1字节来对齐，所以把这个成员存放在 24 内存单元中。 


然后整个结构体的长度必须为所有对齐参数的整数倍，当前长度为25，不是所有对齐参数整数倍，必须调整为32，才是所有参数整数倍。 


所以这个结构体的长度为32。 



如果结构体中出现子结构体怎么办？我们在确定子结构体的对齐参数时，应该就是它的所有成员使用的对齐参数中最大的一个。 


举例： 




```
struct t{ 

    char a; 

    int b; 

};



struct s{ 

   char c; 

   struct t d; 

   char e; 

}; 
```


在32位操作系统下的长度。 


首先确定t的大小为8，它的所有成员使用的对齐参数最大为4。 


再考察s： 


首先 char 型变量c，在32位地址空间中，char型占1个字节，所以按照上面的对齐条件，这个成员应该按照对其参数 min(sizeof(char), 8) = 1字节来对齐，所以把这个成员存放在 0 内存单元中。 


然后 struct t型变量d，在32位地址空间中，struct t占8个字节，所以按照上面的对齐条件，这个成员应该按照对其参数 4 字节来对齐，所以把这个成员存放在 4~11 内存单元中。 


然后 char型变量e，在32位地址空间中，char型占1个字节，所以按照上面的对齐条件，这个成员应该按照对其参数 min(sizeof(char), 8) = 1字节来对齐，所以把这个成员存放在 12 内存单元中。 


然后整个结构体的长度必须为所有对齐参数的整数倍，当前长度为13，不是所有对齐参数整数倍，必须调整为16，才是所有参数整数倍。 


所以此结构体大小为16. 